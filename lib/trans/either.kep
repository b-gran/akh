/**
 * @fileOverview Either monad transformer.
 */
package EitherT
with
    import '../structure' {Monad Monoid Transformer}
in {

var Right = \x -> ({'right': true, 'x': x});

var Left = \x -> ({'right': false, 'x': x});

var runEitherT = \m ->
    m.run;

/* Transformer
 ******************************************************************************/
/**
 * Either monad transformer.
 * 
 * @param m Base monad.
 */
EitherT = \m -> {
    var Instance = function \run =self-> {
        self.run = run;
    };
    
    Monad(Instance,
        \x ->
            new Instance (
                m.of <| Right x),
        
        \f =c->
            new Instance ( 
                runEitherT(c).chain \ {right x} ->
                    ?right
                        :runEitherT (f x)
                        :m.of <| Left x));
    
    Monoid(Instance,
        new Instance (
            m.of <| Left m.zero),
        
        \b =a->
            new Instance (
                runEitherT(a).chain \ {right x} ->
                    ?right
                        :m.of <| Right x
                        :runEitherT b));
    
    Transformer(Instance, m,
        \t ->
            new Instance (
                t.chain(\x -> m.of <| Right x)));
    
    // Either
    Instance.right = Instance.prototype.right = Instance.of;
    
    Instance.left = Instance.prototype.left = \x ->
        new Instance (
            m.of <| Left x);
    
    return Instance;
};

/* Running
 ******************************************************************************/
/**
 * Perform an either computation with mapping functions.
 * 
 * @param m EitherT computation.
 * @param l Left completion function that maps left value to inner monad.
 * @param r Right completion function that maps right value to inner monad.
 */
EitherT.eitherT = \m l r ->
    runEitherT(m)
        .chain\{right x} ->
            ?right : r x : l x;

}