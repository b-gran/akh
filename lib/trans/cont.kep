/**
 * @fileOverview Continuation monad transformer.
 */
package ContT
with
    import '../structure' {Monad Transformer},
    import '../_tail' {Tail trampoline}
in {
    
/* Interface
 ******************************************************************************/
var ContMonat = \instance callcc -> {
    /**
     * M.callcc(f)
     * 
     * Call `f` with the current continuation. If `f` returns a computation,
     * discard the existing continuation and return the result. If `f` returns 
     * the result of calling the continuation with a computation, execution continues.
     */
    instance.callcc = instance.prototype.callcc = callcc;
    
    return instance;
};

/* Transformer
 ******************************************************************************/
var runContT = \m k ->
    new Tail(m.run, k);

/**
 * Continuation monad transformer.
 * 
 * @param m Base monad.
 */
ContT = \m -> {
    var Instance = function \run =self-> {
        self.run = run;
    };
    
    Monad(Instance,
        \x ->
            new Instance\k -> k x,
        
        \c f ->
            new Instance\k ->
                runContT(c, \x ->
                    runContT(f x, k)));
    
    Transformer(Instance,
        \t ->
            new Instance\k ->
                t.chain(k \> trampoline));
    
    // Callcc
    ContMonat(Instance,
        let
            reify = \k ->
                \x ->
                    new Instance\_ -> k x
        in
            \f ->
                new Instance\k ->
                    runContT(
                        f <| reify k,
                        k));
    
    return Instance;
};

/* Running
 ******************************************************************************/
/**
 * Perform a continuation computation and complete with `k`.
 * 
 * @param m ContT computation.
 * @param k Outer continuation.
 */
ContT.runContT = runContT \>> trampoline;

}