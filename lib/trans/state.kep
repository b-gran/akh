/**
 * @fileOverview State monad transformer.
 * 
 * Value and state are stored in Pairs of `{x, s}`.
 * 
 * @TODO: There is probably a better way to implement tail calls.
 */
package StateT
with
    import '../structure' {Monad Monoid Transformer},
    import '../trampoline' Trampoline#{thunk run}
in {

/**
 * Value, state pair.
 */
var Pair = \x s -> ({
    'x': x,
    's': s
});

/* Interface
 ******************************************************************************/
var StateMonad = \instance get put -> {
    /**
     * M.get
     * 
     * Return the current state.
     */
    instance.get = instance.prototype.get = get;
    
    /**
     * M.put(s)
     * 
     * Set the current state to `s`.
     */
    instance.put = instance.prototype.put = put;
    
    /**
     * M.modify(f)
     * 
     * Map the current state to a new state with function `f`.
     */
    instance.modify = instance.prototype.modify = \f ->
        get.chain(f \> put);
};

/* Transformer
 ******************************************************************************/
/**
 * Run a state continuation to get the inner trampoline.
 */
var runStateT = \m s ->
    m.run(s);

/**
 * State monad transformer.
 * 
 * @param m Base monad.
 */
StateT = \m -> {
    var Instance = function \run =self-> {
        self.run = run;
    };

    Monad(Instance,
        \x ->
            new Instance\s ->
                Trampoline.of <| m.of <| Pair(x, s),
        
        \f =c->
            new Instance \s ->
               thunk(c.run, s).chain \ t ->
                    Trampoline.of <| t.chain \ {x s} ->
                        run <| runStateT(f x, s));
    
    Monoid(Instance,
        new Instance\_ ->
            Trampoline.of <| m.zero,
        
        \b =a->
            new Instance\s ->
                thunk(a.run, s).chain \ t ->
                    runStateT(b, s).chain \ k ->
                        Trampoline.of <| t.concat(k));
    
    Transformer(Instance, m,
        \t ->
            new Instance\s ->
                Trampoline.of <| t.chain\x -> m.of <| Pair(x, s));
    
    StateMonad(Instance,
        new Instance\s ->
            Trampoline.of <| m.of <| Pair(s, s),
        
        \s ->
            new Instance \_ ->
                Trampoline.of <| m.of <| Pair(s, s));
    
    return Instance;
};

/* Running
 ******************************************************************************/
/**
 * Perform a stateful computation and return resulting value, state pair.
 * 
 * @param m StateT computation.
 * @param s Initial state.
 */
StateT.runStateT = runStateT \>> run;

/**
 * Perform a stateful computation and return resulting value.
 * 
 * @param m StateT computation.
 * @param s Initial state.
 */
StateT.evalStateT =
    StateT.runStateT
    \>> \n ->
        n.chain\{x} -> n.of(x);

/**
 * Perform a stateful computation and return resulting state.
 * 
 * @param m StateT computation.
 * @param s Initial state.
 */
StateT.execStateT =
    StateT.runStateT
    \>> \n ->
        n.chain\{s} -> n.of(s);

}