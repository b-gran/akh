package (
    chain
    map
    ap
    concat
    
    liftM
    liftM2
    
    next
    sequencea
    sequence
    mapM
    foldM)
{

/* Generic versions of ops
 ******************************************************************************/
chain = \c f -> c.chain(f);

map = \f m -> m.map(f);

ap = \f a -> f.ap(a);

concat = \a b -> a.concat(b);

/* Lifting
 ******************************************************************************/
/**
 * Create a monad from binary function `f` that gets its arguments from a
 * monadic value.
 */
liftM = map;

/**
 * Create a monad from binary function `f` that gets its arguments from two
 * monadic values.
 */
liftM2 = \f m1 m2 ->
    m1.chain \ x ->
    m2.map   \ y ->
        f(x, y);

/* Sequencing
 ******************************************************************************/
/**
 * Perform `p` then `q`. Return result from `q`.
 */
next = \p q -> p.chain(\_ -> q);

/**
 * Perform a sequence of computations left to right.
 * 
 * @param arr Array of computations.
 */
sequencea = \arr -> Array.prototype.reduce.call(arr, next);

/**
 * Perform a sequence of computations from arguments left to right.
 */
sequence = \args(...) -> sequencea(args);

}