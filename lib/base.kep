package (
    chain
    map
    ap
    concat
    
    liftM
    liftM2
    
    next
    sequencea
    sequence
    mapM
    foldM)
{

/* Generic versions of ops
 ******************************************************************************/
chain = \c f -> c.chain(f);

map = \f m -> m.map(f);

ap = \f a -> f.ap(a);

concat = \a b -> a.concat(b);

/* Lifting
 ******************************************************************************/
liftM = \f m ->
    m.chain(f \> m.of);

liftM2 = \f m1 m2 ->
    m1.chain \ x ->
    m2.chain \ y ->
    m1.of(f(x, y));

/* Sequencing
 ******************************************************************************/
/**
 * Perform `p` then `q`. Return result from `q`.
 */
next = \p q -> p.chain(\_ -> q);

/**
 * Perform a sequence of computations left to right.
 * 
 * @param arr Array of computations.
 */
sequencea = \arr -> Array.prototype.reduce.call(arr, next);

/**
 * Perform a sequence of computations from arguments left to right.
 */
sequence = \args(...) -> sequencea(args);


}