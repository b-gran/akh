package (
    Applicative
    Chain
    Functor
    Monad
    Monoid
    Semigroup
    Transformer)
{


Applicative = \instance of ap -> {
    instance.of = instance.prototype.of = of;
    
    instance.ap = ap;
    instance.prototype.ap = \b =self-> ap(self, b);
    
    // Derived
    Functor(instance,
        instance.map || \f m ->
            of(f).ap(m));
    
    return instance;
};

Chain = \instance chain -> {
    instance.chain = chain;
    instance.prototype.chain = \f =self-> chain(self, f);
    
    return instance;
};

Functor = \instance map -> {
    instance.map = map;
    instance.prototype.map = \f =self-> map(f, self);
    
    return instance;
};

Monoid = \instance zero plus -> {
    instance.zero = instance.prototype.zero = zero;
    
    Semigroup(instance,
        plus);
    
    return instance;
};

Monad = \instance of chain -> {
    instance.of = instance.prototype.of = of;
    
    Chain(instance,
        chain);
    
    // Derived
    Functor(instance,
        \f m ->
            chain(m, f \> m.of));
    
    Applicative(instance,
        of,
        \f m ->
            chain(f, \f -> m.map(f)));

    return instance;
};

Semigroup = \instance plus -> {
    instance.concat = plus;
    instance.prototype.concat = \c =self-> plus(self, c);

    return instance;
};



Transformer = let 
    liftInner := \lift outer inner -> {
        if (inner.liftInner)
            outer.liftInner = liftInner(
                lift,
                (lift <\ inner.liftInner),
                inner.liftInner);
        return outer;
    }
in
    \instance m lift -> {
        instance.inner = instance.prototype.inner = m;
        
        instance.lift = instance.prototype.lift = lift;
        
        // Derived
        if (m.lift)
            instance.liftInner = instance.prototype.liftInner = liftInner(lift, (lift <\ m.lift), m);
        
        return instance;
    };


}
